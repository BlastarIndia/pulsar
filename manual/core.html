<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Organization">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta itemprop="name" content="Pulsar">
<meta itemprop="description" content="Erlang-like actors for Clojure">
<title>
  
    Pulsar Core - 
   Pulsar
</title>
<!--<link rel="shortcut icon" href="/images/icons/loading_icon.png">-->
<link href="/pulsar/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/pulsar/css/pygments/jekyll-github.css"  rel="stylesheet" type="text/css">
<!-- comment out the next line to disable line numbers -->
<link href="/pulsar/css/pygments/linenos.css"        rel="stylesheet" type="text/css">
<!-- <link href="/pulsar/css/prettify/sunburst.css" rel="stylesheet" type="text/css"> -->
<link href="/pulsar/css/site.css?now" rel="stylesheet" type="text/css">



</head>
<body>

<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container-fluid">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
      </a>
      <a class="brand" href="/pulsar/">Pulsar</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li class="icon github"><a href="https://github.com/puniverse/pulsar"><img src="/pulsar/images/icons/github.png">View on Github</a></li>
          <li><a href="/pulsar/api/index.html">API</a> </li>
          <li class="icon bug"><a href="https://github.com/puniverse/pulsar/issues/new"><img src="/pulsar/images/icons/bug.png">File a bug</a></li>
          <!-- <li class="icon source"><a href="https://github.com/puniverse/pulsar/blob/master/CONTRIBUTING.md"><img src="/images/icons/source.png">Contribute</a> </li> -->
          <li class="icon talk"><a href="https://groups.google.com/forum/#!forum/quasar-pulsar-user"><img src="/pulsar/images/icons/talk.png">Discuss</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>


<div class="container-fluid">
  <div class="row-fluid">
    <div class="span3">
  <div class="well well-small sidebar-nav">
    <ul class="nav nav-list">
      
        <li class="nav-header">Getting Started</li>
        
          
          
            
          
          
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/getting-started.html">
                Getting Started
              </a>
              
            </li>
          
        
          
          
            
          
          
          
        
          
          
            
          
          
          
        
          
          
            
          
          
          
        
          
          
            
          
          
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/news.html">
                News
              </a>
              
            </li>
          
        
      
        <li class="nav-header">User Manual</li>
        
          
          
            
          
          
          
            <li>
              <a class="active" href="/pulsar/manual/core.html">
                Pulsar Core
              </a>
              
              <ul class="nav nav-list"><li><a href="#quasar-and-pulsar">Quasar and&nbsp;Pulsar</a></li><li><a href="#fibers">Fibers</a></li><li><a href="#promises-promises">Promises,&nbsp;Promises</a></li><li><a href="#channels">Channels</a></li></ul>
              
            </li>
          
        
          
          
            
          
          
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/manual/actors.html">
                Pulsar's Actor System
              </a>
              
            </li>
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/manual/async.html">
                core.async
              </a>
              
            </li>
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/manual/cluster.html">
                Clustering
              </a>
              
            </li>
          
        
          
          
            
          
          
          
            <li>
              <a  href="/pulsar/manual/examples.html">
                Examples
              </a>
              
            </li>
          
        
          
          
            
          
          
          
        
      
      <li class="divider"></li>
    </ul>
  </div>
</div>

    <div class="span8" id="content-container">

      <span class="edit-on-github">
  <a href="https://github.com/puniverse/pulsar/edit/master/docs/manual/core.md">Edit on Github</a>
</span>


      
      <div class="page-header">
        <h1>Pulsar Core
          
        </h1>
      </div>
      

      <div id="content">
<h2 id="quasar-and-pulsar">Quasar and&nbsp;Pulsar</h2>

<p>Pulsar is a Clojure <span class="caps">API</span> to <a href="https://github.com/puniverse/quasar">Quasar</a>. Many of the concepts explained below are actually implemented in&nbsp;Quasar.</p>

<h2 id="fibers">Fibers</h2>

<p>Fibers are lightweight threads. They provide functionality similar to threads, and a similar <span class="caps">API</span>, but they’re not managed by the <span class="caps">OS.</span> They are lightweight (an idle fiber occupies ~400 bytes of <span class="caps">RAM</span>), and you can have millions of them in an application. If you are familiar with Go, fibers are like goroutines. Fibers in Pulsar (well, Quasar, actually) are scheduled by one or more <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>s. </p>

<p>One significant difference between Fibers and Threads is that Fibers are not preempted; i.e. a fiber is (permanently or temporarily) unscheduled by the scheduler only if it terminates, or if it calls one of a few specific Java methods that cause the fiber to become suspended. A function that calls a suspending operation is called a <em>suspendable</em> function, and a function that calls another suspendable function is itself&nbsp;suspendable. </p>

<p>Suspendable functions require special bytecode instrumentation (performed by an instrumentation agent), so they must be explicitly designated as&nbsp;such.
The function <code>suspendable!</code> marks a given function as a suspendable function (this operation cannot be undone). The <code>defsfn</code> macro, with the same syntax as <code>defn</code> defines a suspendable&nbsp;function.</p>

<p class="alert alert-info"><strong>Note</strong>: All functions (i.e. <code>fn</code>s) passed to any of the Pulsar <span class="caps">API</span> functions and macros are automatically made suspendable, so in most simple cases you will never need to use <code>sfn</code>, <code>defsfn</code> or&nbsp;<code>suspendable!</code>.</p>

<p class="alert alert-warn"><strong>Note</strong>: One thing to watch out for in suspendable functions is lazy-seqs. If the function consumes a seq, it’s probably a good idea to force it with <code>doall</code> before passing it to the&nbsp;function.</p>

<h3 id="spawning-fibers">Spawning&nbsp;Fibers</h3>

<p>To create a fiber of a function <code>f</code> that takes arguments <code>arg1</code> and <code>arg2</code>,&nbsp;run</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">spawn-fiber</span> <span class="nv">f</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span>
</span></code></pre></div>
<p><code>spawn-fiber</code> automatically marks <code>f</code> as suspendable, so there’s no need to do so&nbsp;explicitly.</p>

<p><code>spawn-fiber</code> takes optional keyword&nbsp;arguments:</p>

<ul>
  <li><code>:name</code> - The fiber’s&nbsp;name.</li>
  <li><code>:fj-pool</code> - The <code>ForkJoinPool</code> in which the fiber will&nbsp;run.
If <code>:fj-pool</code> is not specified, then the pool used will be either the pool of the fiber calling <code>spawn-fiber</code>, or, if <code>spawn-fiber</code> is not called from within a fiber, a default&nbsp;pool.</li>
  <li><code>:stack-size</code> - The initial fiber data stack&nbsp;size.</li>
</ul>

<p>The fiber will terminate when <code>f</code> completes&nbsp;execution. </p>

<p class="alert alert-info"><strong>Note</strong>: Spawning a fiber is a very cheap operation in both computation and memory. Do not fear creating many (thousands, tens-of-thousands or even hundereds-of-thousands)&nbsp;fibers.</p>

<h3 id="joining-fibers">Joining&nbsp;Fibers</h3>

<p>To wait for the fiber’s termination,&nbsp;use</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">)</span>
</span></code></pre></div>
<p>If <code>f</code> returns a value, <code>join</code> will return that value. If <code>f</code> throws an exception, <code>join</code> will throw that&nbsp;exception.</p>

<p>You can also wait for a fiber’s termination for a given duration. The following will wait for half a second for the fiber to&nbsp;terminate:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nb">join </span><span class="mi">500</span> <span class="nv">java.util.concurrent.TimeUnit/MILLISECONDS</span> <span class="nv">fiber</span><span class="p">)</span>
</span></code></pre></div>
<p>The following will have the same&nbsp;effect:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nb">join </span><span class="mi">500</span> <span class="ss">:ms</span> <span class="nv">fiber</span><span class="p">)</span>
</span></code></pre></div>
<h3 id="bindings">Bindings</h3>

<p>Fibers behave well with Clojure <code>bindings</code>. A newly spawned fiber inherits the bindings in effect at the time of&nbsp;spawning,
and bindings decleared in a fiber last throughout the fiber’s lifetime. This is demonstrated in the following tests&nbsp;taken
from the Pulsar test&nbsp;suite:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*foo*</span> <span class="mi">40</span><span class="p">)</span>
</span><span id="line-2">
</span><span id="line-3"><span class="p">(</span><span class="nf">facts</span> <span class="s">&quot;fiber-bindings&quot;</span>
</span><span id="line-4">      <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Fiber inherits thread bindings&quot;</span>
</span><span id="line-5">            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">fiber</span>
</span><span id="line-6">                  <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*foo*</span> <span class="mi">20</span><span class="p">]</span>
</span><span id="line-7">                    <span class="p">(</span><span class="nf">spawn-fiber</span>
</span><span id="line-8">                     <span class="o">#</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v1</span> <span class="nv">*foo*</span><span class="p">]</span>
</span><span id="line-9">                        <span class="p">(</span><span class="nf">Fiber/sleep</span> <span class="mi">200</span><span class="p">)</span>
</span><span id="line-10">                        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v2</span> <span class="nv">*foo*</span><span class="p">]</span>
</span><span id="line-11">                          <span class="p">(</span><span class="nb">+ </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))))]</span>
</span><span id="line-12">              <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span>
</span><span id="line-13">            <span class="nv">=&gt;</span> <span class="mi">40</span><span class="p">)</span>
</span><span id="line-14">      <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Bindings declared in fiber last throughout fiber lifetime&quot;</span>
</span><span id="line-15">            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">fiber</span>
</span><span id="line-16">                  <span class="p">(</span><span class="nf">spawn-fiber</span>
</span><span id="line-17">                   <span class="o">#</span><span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*foo*</span> <span class="mi">15</span><span class="p">]</span>
</span><span id="line-18">                      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v1</span> <span class="nv">*foo*</span><span class="p">]</span>
</span><span id="line-19">                        <span class="p">(</span><span class="nf">Fiber/sleep</span> <span class="mi">200</span><span class="p">)</span>
</span><span id="line-20">                        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v2</span> <span class="nv">*foo*</span><span class="p">]</span>
</span><span id="line-21">                          <span class="p">(</span><span class="nb">+ </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))))]</span>
</span><span id="line-22">              <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span>
</span><span id="line-23">            <span class="nv">=&gt;</span> <span class="mi">30</span><span class="p">))</span>
</span></code></pre></div>
<h3 id="compatibility-with-clojure-concurrency-constructs">Compatibility with Clojure Concurrency&nbsp;Constructs</h3>

<p>Code running in fibers may make free use of Clojure atoms and&nbsp;agents. </p>

<p>Spawning or dereferencing a future created with <code>clojure.core/future</code> is ok, but there’s a better alternative: you can turn a spawned fiber into a future with <code>fiber-&gt;future</code> and can then dereference or call regular future functions on the returned value, like <code>realized?</code> (In fact, you don’t even have to call <code>fiber-&gt;future</code>; fibers already implement the <code>Future</code> interface and can be treated as futures directly, but this may change in the future, so, until the <span class="caps">API</span> is fully settled, we recommend using&nbsp;<code>fiber-&gt;future</code>).</p>

<p>Running a <code>dosync</code> block inside a fiber is discouraged as it uses locks internally, but your mileage may&nbsp;vary.</p>

<p>Promises are supported and encouraged, but you should not make use of <code>clojure.core/promise</code> to create a promise that’s to be dereferenced in a fiber. Pulsar provides a different – yet completely compatible – form of promises, as you’ll see&nbsp;soon.</p>

<h3 id="strands">Strands</h3>

<p>Before we continue, one more bit of nomenclature: a single flow of execution in Quasar/Pulsar is called a <em>strand</em>. To put it more simply, a strand is either a normal <span class="caps">JVM</span> thread, or a&nbsp;fiber.</p>

<p>The strand abstraction helps you write code that works whether it runs in a fiber or not. For example, <code>(Strand/currentStrand)</code> returns the current fiber, if called from a fiber, or the current thread, if not. <code>(Strand/sleep millis)</code> suspends the current strand for a given number of milliseconds whether it’s a fiber or a normal thread. Also, <code>join</code> works for both fibers and threads (although for threads <code>join</code> will always return&nbsp;<code>nil</code>).</p>

<h2 id="promises-promises">Promises,&nbsp;Promises</h2>

<p>Promises, also known as dataflow variables, are an especially effective, and simple, concurrency&nbsp;primitive.</p>

<p>A promise is a value that may only be set once, but read multiple times. If the promise is read before the value is set, the reading strand will block until the promise has been set, and then return its&nbsp;value.</p>

<p>Promises are defined in <code>clojure.core</code>, but <code>...pulsar.core</code> provides its own, fully compatible&nbsp;version.</p>

<p>A promise is created simply like&nbsp;this:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span></code></pre></div>
<p>And is set with <code>deliver</code>. It can be read by dereferencing it with <code>@</code>, and you can test whether it’s been set with <code>realized?</code> (other than the <code>promise</code> function itself, all other functions, like <code>deliver</code> and <code>realized</code> are those defined in&nbsp;<code>clojure.core</code>)</p>

<p>The <code>promise</code> function defined in Pulsar creates a promise, that, when dereferenced within a fiber, simply blocks the fiber and not the entire <span class="caps">OS</span> thread it’s running&nbsp;in.</p>

<p>Here’s an example of using promises from the&nbsp;tests:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v1</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-2">     <span class="nv">v2</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-3">     <span class="nv">v3</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-4">     <span class="nv">v4</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-5">     <span class="nv">f1</span> <span class="p">(</span><span class="nf">spawn-fiber</span>  <span class="o">#</span><span class="p">(</span><span class="nf">deliver</span> <span class="nv">v2</span> <span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v1</span> <span class="mi">1</span><span class="p">)))</span>
</span><span id="line-6">     <span class="nv">t1</span> <span class="p">(</span><span class="nf">spawn-thread</span> <span class="o">#</span><span class="p">(</span><span class="nf">deliver</span> <span class="nv">v3</span> <span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v1</span> <span class="o">@</span><span class="nv">v2</span><span class="p">)))</span>
</span><span id="line-7">     <span class="nv">f2</span> <span class="p">(</span><span class="nf">spawn-fiber</span>  <span class="o">#</span><span class="p">(</span><span class="nf">deliver</span> <span class="nv">v4</span> <span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v3</span> <span class="o">@</span><span class="nv">v2</span><span class="p">)))]</span>
</span><span id="line-8"> <span class="p">(</span><span class="nf">Strand/sleep</span> <span class="mi">50</span><span class="p">)</span>
</span><span id="line-9"> <span class="p">(</span><span class="nf">deliver</span> <span class="nv">v1</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="line-10"> <span class="o">@</span><span class="nv">v4</span><span class="p">)</span> <span class="c1">; =&gt; 5</span>
</span></code></pre></div>
<p>This example shows how promises are set, and read, by both fibers and regular&nbsp;threads.</p>

<p>But Pulsar’s promises have one additional, quite nifty, feature. If you pass an optional function to <code>promise</code>, a new fiber running that function will be spawned, and the promise will receive the value returned from the function. Here’s another example from the&nbsp;tests:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">v0</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-2">     <span class="nv">v1</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)</span>
</span><span id="line-3">     <span class="nv">v2</span> <span class="p">(</span><span class="nf">promise</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v1</span> <span class="mi">1</span><span class="p">))</span>
</span><span id="line-4">     <span class="nv">v3</span> <span class="p">(</span><span class="nf">promise</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v1</span> <span class="o">@</span><span class="nv">v2</span><span class="p">))</span>
</span><span id="line-5">     <span class="nv">v4</span> <span class="p">(</span><span class="nf">promise</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">+ </span><span class="o">@</span><span class="nv">v3</span> <span class="o">@</span><span class="nv">v2</span><span class="p">)</span> <span class="o">@</span><span class="nv">v0</span><span class="p">))]</span>
</span><span id="line-6"> <span class="p">(</span><span class="nf">Strand/sleep</span> <span class="mi">50</span><span class="p">)</span>
</span><span id="line-7"> <span class="p">(</span><span class="nf">deliver</span> <span class="nv">v1</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="line-8"> <span class="p">(</span><span class="nf">mapv</span> <span class="nv">realized?</span> <span class="p">[</span><span class="nv">v0</span> <span class="nv">v1</span> <span class="nv">v2</span> <span class="nv">v3</span> <span class="nv">v4</span><span class="p">])</span> <span class="c1">; =&gt; [false true true true false]</span>
</span><span id="line-9"> <span class="p">(</span><span class="nf">deliver</span> <span class="nv">v0</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="line-10"> <span class="o">@</span><span class="nv">v4</span><span class="p">)</span> <span class="c1">; =&gt; 10</span>
</span></code></pre></div>
<h2 id="channels">Channels</h2>

<p>Channels are queues used to pass messages between strands (remember, strands are a general name for threads and fibers). If you are familiar with Go, Pulsar channels are like Go channels. The&nbsp;call</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">channel</span><span class="p">)</span>
</span></code></pre></div>
<p>creates and returns a new&nbsp;channel. </p>

<p>A more general form of the <code>channel</code> function&nbsp;is:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">channel</span> <span class="nv">capacity</span> <span class="nv">overflow-policy</span><span class="p">)</span>
</span></code></pre></div>
<p>The channel’s <code>capacity</code> is the number of messages that can wait in the queue. A positive integer creates a bounded queue that can hold up to the given number of messages until they’re consumed. A capacity of -1 specifies an unbounded channel (unlimited number of pending messages), and a capacity of 0 specifies a <em>transfer channel</em>, one where the producer is blocked until a consumer requests a message and&nbsp;vice-versa.</p>

<p><code>overflow-policy</code> specifies what happens to the producer (sender) of a message when the channel’s capacity is exhausted, and may be one&nbsp;of:</p>

<ul>
  <li><code>:throw</code> - throws an&nbsp;exception </li>
  <li><code>:drop</code> - silently drops (discards) the&nbsp;message</li>
  <li><code>:block</code> - blocks the sender until messages are consumed from the channel and it has remaining&nbsp;capacity</li>
  <li><code>:displace</code> - removes the oldest message waiting in the channel to make room for the new&nbsp;message.</li>
</ul>

<p>If you leave out the <code>overflow-policy</code> argument, the default policy of <code>:block</code> is used. Leaving both out (and simply calling <code>(channel)</code> is the same as <code>(channel 0 :block)</code> (obviously, a transfer channel (a channel of capacity 0), would only work with a <code>:block</code>&nbsp;policy). </p>

<p>Bounded channels are generally faster than unbounded&nbsp;channels. </p>

<p>Use of the <code>:displace</code> policy places an additional restriction on the channel: its messages may be consumed by a single strand&nbsp;only.</p>

<h3 id="sending-and-receiving-messages">Sending and receiving&nbsp;messages</h3>

<p>Sending a message to a channel is&nbsp;simple:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">snd</span> <span class="nv">channel</span> <span class="nv">message</span><span class="p">)</span>
</span></code></pre></div>
<p><code>message</code> can be any object, but not <code>nil</code>. Receiving a message from a channel is equaly&nbsp;easy:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">rcv</span> <span class="nv">channel</span><span class="p">)</span>
</span></code></pre></div>
<p>The <code>rcv</code> function returns the first message in the channel (the one that has waited there the longest), if there is one. If the channel is empty, the function will block until a message is sent to the channel, and will then return&nbsp;it.</p>

<p class="alert alert-info"><strong>Note</strong>: <code>rcv</code> is a suspendable function, so any function calling it must also be decalred suspendable. But remember, the function passed to <code>spawn-fiber</code> is automatically made&nbsp;suspendable.</p>

<p>It is also possible to limit the amount of time <code>rcv</code> will wait for a&nbsp;message:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">rcv</span> <span class="nv">channel</span> <span class="mi">10</span> <span class="nv">java.util.concurrent.TimeUnit/MILLISECONDS</span><span class="p">)</span>
</span></code></pre></div>
<p>or,&nbsp;equivalently:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">rcv</span> <span class="nv">channel</span> <span class="mi">10</span> <span class="ss">:ms</span><span class="p">)</span>
</span></code></pre></div>
<p>These calls will wait for a message for 10 milliseconds before giving up and returning&nbsp;<code>nil</code>.</p>

<h3 id="closing-the-channel">Closing the&nbsp;channel</h3>

<p>After&nbsp;calling </p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">close!</span> <span class="nv">channel</span><span class="p">)</span>
</span></code></pre></div>
<p>any future messages sent to the channel will be ignored. Any messages already in the channel will be received. Once the last message has been received, another call to <code>rcv</code> will return&nbsp;<code>nil</code>. </p>

<h3 id="channel-selection--sel-and-select">Channel Selection – <code>sel</code> and&nbsp;<code>select</code></h3>

<p>A powerful tool when working with channels is the ability to wait on a message from several channels at&nbsp;once.</p>

<p>The <code>sel</code> function takes a collection containing <em>channel operation descriptors</em>. A descriptor is either a channel or a pair (vector) of a channel and a message. Each channel in the sequence represents a <code>rcv</code> attempt, and each channel-message pair represents a <code>snd</code> attempt. The <code>sel</code> function performs at most one operation on the sequence, a <code>rcv</code> or a <code>snd</code>, which is determined by the first operation that can succeed. If no operation can be carried out immediately, <code>sel</code> will block until an operation can be&nbsp;performed.</p>

<p>For example, in the following&nbsp;call,</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">sel</span> <span class="p">[</span><span class="nv">ch1</span> <span class="p">[</span><span class="nv">ch2</span> <span class="nv">msg1</span><span class="p">]</span> <span class="nv">ch3</span> <span class="p">[</span><span class="nv">ch4</span> <span class="nv">msg2</span><span class="p">]])</span>
</span></code></pre></div>
<p>a message will either be received from <code>ch1</code> or <code>ch2</code>, or one will be sent to eiter <code>ch2</code> or <code>ch4</code>. If, for instance, <code>ch2</code> will become available for reading (i.e. it has been sent a message) first, than only that operation, in this case a <code>rcv</code> will be performed on <code>ch1</code>. If <code>ch2</code> becomes available for writing before that happens, then only that operation, a <code>snd</code>, will be performed. If two operations are available at the same time, one will be chosen randomly (unless the <code>:priority</code> option is set, as we’ll see&nbsp;later).</p>

<p>Note that if a channel’s overflow policy is anything by <code>:block</code>, then <code>snd</code> operations are always&nbsp;available.</p>

<p>The general form of the <code>sel</code> function&nbsp;is</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">sel</span> <span class="nv">ports</span> <span class="o">&amp;</span> <span class="nv">opts</span><span class="p">)</span>
</span></code></pre></div>
<p><code>sel</code> returns a vector of two values describing the single operation that has been performed. The first is the message received if the operation is a <code>rcv</code>, or <code>nil</code> if it’s a <code>snd</code>; the second is the channel on which the operation has been&nbsp;performed.</p>

<p>The <code>sel</code> function takes two options. If <code>:priority</code> is set to <code>true</code> (thus: <code>:priority true</code>), then if more than one operation becomes available at the same time, then the one that’s listed earlier in the channels collection will be&nbsp;performed.</p>

<p>The second option is <code>:timeout</code>, which takes an integer argument specifying the timeout in milliseconds. If the timeout elapses without any of the operations succeeding, <code>sel</code> will return <code>nil</code>. If the timeout value is <code>0</code>, then <code>sel</code> will never block. It will attempt to perform any of the requested operations, but if none are <em>immediately</em> available, it will return&nbsp;<code>nil</code>.</p>

<p>So, for example,&nbsp;calling</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">sel</span> <span class="p">[</span><span class="nv">ch1</span> <span class="nv">ch2</span> <span class="nv">ch3</span><span class="p">]</span> <span class="ss">:timeout</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></div>
<p>Will return, <code>[msg ch]</code> if any of the channels was immediately available for a <code>rcv</code>, or <code>nil</code> if none of them&nbsp;were.</p>

<p>The <code>select</code> macro performs a very similar operation as <code>sel</code>, but allows you to specify an action to perform depending on which operation has&nbsp;succeeded.
It takes an even number of expressions, ordered as (ops1, action1, ops2, action2 …) with the ops being a channel operation descriptior (remember: a descriptor is either a channel for an <code>rcv</code> operation, or a vector of a channel and a message specifying a <code>snd</code> operation) or a collection of descriptors, and the actions are Clojure expressions. Like <code>sel</code>, <code>select</code> performs at most one operation, in which case it will run the operation’s respective action and return its&nbsp;result.</p>

<p>An action expression can bind values to the operations results. The action expression may begin with a vector of one or two symbols. In that case, the first symbol will be bound to the message returned from the successful receive in the respective ops clause (or <code>nil</code> if the successful operation is a <code>snd</code>), and the second symbol, if present, will be bound to the successful operation’s&nbsp;channel.</p>

<p>Like <code>sel</code>, <code>select</code> blocks until an operation succeeds, or, if a <code>:timeout</code> option is specified, until the timeout (in milliseconds) elapses. If a timeout is specfied and elapses, <code>select</code> will run the action in an optional <code>:else</code> clause and return its result, or, if an <code>:else</code> clause is not present, <code>select</code> will return&nbsp;<code>nil</code>.</p>

<p>Here’s an&nbsp;example:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nb">select </span><span class="ss">:timeout</span> <span class="mi">100</span> 
</span><span id="line-2">        <span class="nv">c1</span> <span class="p">([</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;received&quot;</span> <span class="nv">v</span><span class="p">))</span>
</span><span id="line-3">        <span class="p">[[</span><span class="nv">c2</span> <span class="nv">m2</span><span class="p">]</span> <span class="p">[</span><span class="nv">c3</span> <span class="nv">m3</span><span class="p">]]</span> <span class="p">([</span><span class="nv">v</span> <span class="nv">c</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;sent to&quot;</span> <span class="nv">c</span><span class="p">))</span>
</span><span id="line-4">        <span class="ss">:else</span> <span class="s">&quot;timeout!&quot;</span><span class="p">)</span>
</span></code></pre></div>
<p>In the example, if a message is received from channel <code>c1</code>, then it will be printed. If a message is sent to either <code>c2</code> or <code>c3</code>, then the identity of the channel will be printed, and if the 100 ms timeout elapses then “timeout!” will be&nbsp;printed.</p>

<p>Finally, just like <code>sel</code>, you can pass <code>:priority true</code> to <code>select</code>, in which case if more than one operation is available, the first one among them as listed in the <code>select</code> statement will be&nbsp;performed.</p>

<h3 id="channel-groups">Channel&nbsp;Groups</h3>

<p>It is common for a function to always wait to receive from the same set of channels. An alternative to <code>sel</code> can be to create a <code>rcv-group</code>, on which you can call <code>rcv</code> as if it were a simple&nbsp;channel:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">group</span> <span class="p">(</span><span class="nf">rcv-group</span> <span class="nv">ch1</span> <span class="nv">ch2</span> <span class="nv">ch3</span><span class="p">)]</span>
</span><span id="line-2">   <span class="p">(</span><span class="nf">rcv</span> <span class="nv">group</span><span class="p">))</span>
</span></code></pre></div>
<p>You can also use a timeout when receiving from a channel&nbsp;group.</p>

<h3 id="topics">Topics</h3>

<p>Topics are, in a sense, the opposite of rcv-groups. A topic is a send-port (a channel you can send to but not receive from), that broadcasts any message written to it to a number of <em>subscriber</em>&nbsp;channels.</p>

<p>A topic is created simply&nbsp;with:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">topic</span><span class="p">)</span>
</span></code></pre></div>
<p>When a channel <em>subscribes</em> to the topic, it will receive all messages sent to the&nbsp;topic:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">subscribe!</span> <span class="nv">tpc</span> <span class="nv">ch</span><span class="p">)</span>
</span></code></pre></div>
<p>You can also unsubscribe a&nbsp;channel:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">subscribe!</span> <span class="nv">tpc</span> <span class="nv">ch</span><span class="p">)</span>
</span></code></pre></div>
<p>Note that a messages sent to the topic is essentialy replicated to all subscribers, i.e. it will be received once in each&nbsp;channel.</p>

<h3 id="ticker-channels">Ticker&nbsp;Channels</h3>

<p>A channel created with the <code>:displace</code> policy is called a <em>ticker channel</em> because it provides guarantees similar to that of a digital stock-ticker: you can start watching at any time, the messages you read are always read in order, but because of the limited screen size, if you look away or read to slowly you may miss some&nbsp;messages.</p>

<p>The ticker channel is useful when a program component continually broadcasts some information. The size channel’s circular buffer, its “screen” if you like, gives the subscribers some leeway if they occasionally fall behind&nbsp;reading.</p>

<p>As mentioned earlier, a ticker channel is single-consumer, i.e. only one strand is allowed to consume messages from the channel. On the other hand, it is possible, and useful, to create several views of the channel, each used by a different consumer strand. A view is created&nbsp;thus:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">ticker-consumer</span> <span class="nv">ch</span><span class="p">)</span>
</span></code></pre></div>
<p><code>ch</code> must be a channel of bounded capacity with the <code>:displace</code> policy. <code>ticker-consumer</code> returns a <em>receive port</em> (a channel that can only receive messages, not send them) that can be used to receive messages from <code>ch</code>. Each ticker-consumer will yield monotonic messages, namely no message will be received more than once, and the messages will be received in the order they’re sent, but if the consumer is too slow, messages could be&nbsp;lost. </p>

<p>Each consumer strand will use its own <code>ticker-consumer</code>, and each can consume messages at its own pace, and each <code>ticker-consumer</code> port will return the same messages (messages consumed from one will not be removed from the other views), subject possibly to different messages being missed by different consumers depending on their&nbsp;pace.</p>

<h3 id="primitive-channels">Primitive&nbsp;channels</h3>

<p>It is also possible to create channels that carry messages of primitive <span class="caps">JVM</span> types. The analogous primitive channel functions to <code>channel</code>, <code>snd</code> and <code>rcv</code>, are,&nbsp;respectively: </p>

<ul>
  <li><code>int</code> channels: <code>int-channel</code>, <code>snd-int</code>,&nbsp;<code>rcv-int</code></li>
  <li><code>long</code> channels: <code>long-channel</code>, <code>snd-long</code>,&nbsp;<code>rcv-long</code></li>
  <li><code>float</code> channels: <code>float-channel</code>, <code>snd-float</code>,&nbsp;<code>rcv-float</code></li>
  <li><code>double</code> channels: <code>double-channel</code>, <code>snd-double</code>,&nbsp;<code>rcv-double</code></li>
</ul>

<p>Because they don’t require boxing (for this reason <code>snd-xxx</code> and <code>rcv-xxx</code> are actually macros), primitive channels can provide better performance than regular channels. Primitive channels, however, are single-consumer, namely, only a single strand may read messages from any given&nbsp;channel.</p>

<p>Calling <code>rcv-xxx</code> on a closed channel will throw an&nbsp;exception.</p>

<h3 id="channel-lazy-seqs">Channel&nbsp;lazy-seqs</h3>

<p class="centered alert alert-warning"><strong>Note</strong>: Channel lazy-seqs are an experimental&nbsp;feature.</p>

<p>Messages received through channels can be manipulted with Clojure’s sequence manipulation functions by transforming a channel into a <code>lazy-seq</code>. Unfortunately, Clojure implements <code>lazy-seq</code>s with the <code>clojure.lang.LazySeq</code> class, which <em>almost</em> allows a <code>lazy-seq</code> implementation by a channel - but not quite (a simple reordering of a couple of Java lines in the <code>LazySeq</code> class would have made it compatible with channels). The <code>lazy-seq</code> function in the <code>co.paralleluniverse.pulsar.lazyseq</code> namespace therefore creates a <code>lazy-seq</code> that works just like Clojure’s, but uses a slightly different underlying Java implementation. This is unfortunate, because it required a re-implementation of many sequence manipulation&nbsp;functions.</p>

<p>Nevertheless, it’s still possible to work with channels as you would with lazy-seqs, you only need to mind calling the functions in the right&nbsp;namespace.</p>

<p>To create a lazy-seq from a channel, simply&nbsp;call:</p>

<pre><code>(channel->lazy-seq ch)
</code></pre>
<p>Then, manipulating messages with sequence functions is easy. Here are some examples from the&nbsp;tests:</p>

<div class="highlight"><pre><code><span id="line-1"><span class="p">(</span><span class="nf">require</span> <span class="p">[</span><span class="nv">co.paralleluniverse.pulsar.lazyseq</span> <span class="ss">:as</span> <span class="nv">s</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">channel-&gt;lazy-seq</span> <span class="nv">snd-seq</span><span class="p">]])</span>
</span><span id="line-2">
</span><span id="line-3"><span class="p">(</span><span class="nf">facts</span> <span class="s">&quot;channels-seq&quot;</span>
</span><span id="line-4">       <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Receive sequence with sleep&quot;</span>
</span><span id="line-5">             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">channel</span><span class="p">)</span>
</span><span id="line-6">                   <span class="nv">fiber</span> <span class="p">(</span><span class="nf">spawn-fiber</span>
</span><span id="line-7">                          <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span id="line-8">                            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nf">s/take</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">channel-&gt;lazy-seq</span> <span class="nv">ch</span><span class="p">))]</span>
</span><span id="line-9">                              <span class="p">(</span><span class="nf">s/doall</span> <span class="nv">s</span><span class="p">))))]</span>
</span><span id="line-10">               <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">m</span> <span class="mi">10</span><span class="p">]</span>
</span><span id="line-11">                 <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span>
</span><span id="line-12">                 <span class="p">(</span><span class="nf">snd</span> <span class="nv">ch</span> <span class="nv">m</span><span class="p">))</span>
</span><span id="line-13">               <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span>  <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</span><span id="line-14">       <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Map received sequence with sleep&quot;</span>
</span><span id="line-15">             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">channel</span><span class="p">)</span>
</span><span id="line-16">                   <span class="nv">fiber</span> <span class="p">(</span><span class="nf">spawn-fiber</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="p">(</span><span class="nf">s/doall</span> <span class="p">(</span><span class="nf">s/map</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">s/take</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">channel-&gt;lazy-seq</span> <span class="nv">ch</span><span class="p">))))))]</span>
</span><span id="line-17">               <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">m</span> <span class="mi">10</span><span class="p">]</span>
</span><span id="line-18">                 <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span>
</span><span id="line-19">                 <span class="p">(</span><span class="nf">snd</span> <span class="nv">ch</span> <span class="nv">m</span><span class="p">))</span>
</span><span id="line-20">               <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">))</span>
</span><span id="line-21">       <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Filter received sequence with sleep (odd)&quot;</span>
</span><span id="line-22">             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">channel</span><span class="p">)</span>
</span><span id="line-23">                   <span class="nv">fiber</span> <span class="p">(</span><span class="nf">spawn-fiber</span>
</span><span id="line-24">                          <span class="o">#</span><span class="p">(</span><span class="nf">s/doall</span> <span class="p">(</span><span class="nf">s/filter</span> <span class="nv">odd?</span> <span class="p">(</span><span class="nf">s/take</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">channel-&gt;lazy-seq</span> <span class="nv">ch</span><span class="p">)))))]</span>
</span><span id="line-25">               <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">m</span> <span class="mi">10</span><span class="p">]</span>
</span><span id="line-26">                 <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span><span class="nv">null</span>
</span><span id="line-27">                 <span class="p">(</span><span class="nf">snd</span> <span class="nv">ch</span> <span class="nv">m</span><span class="p">))</span>
</span><span id="line-28">               <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
</span><span id="line-29">       <span class="p">(</span><span class="nf">fact</span> <span class="s">&quot;Filter and map received sequence with sleep (even)&quot;</span>
</span><span id="line-30">             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">channel</span><span class="p">)</span>
</span><span id="line-31">                   <span class="nv">fiber</span> <span class="p">(</span><span class="nf">spawn-fiber</span>
</span><span id="line-32">                          <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="p">(</span><span class="nf">s/doall</span>
</span><span id="line-33">                                  <span class="p">(</span><span class="nf">s/filter</span> <span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">10</span><span class="p">)</span>
</span><span id="line-34">                                            <span class="p">(</span><span class="nf">s/map</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span>
</span><span id="line-35">                                                   <span class="p">(</span><span class="nf">s/filter</span> <span class="nv">even?</span>
</span><span id="line-36">                                                             <span class="p">(</span><span class="nf">s/take</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">channel-&gt;lazy-seq</span> <span class="nv">ch</span><span class="p">))))))))]</span>
</span><span id="line-37">               <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">m</span> <span class="mi">10</span><span class="p">]</span>
</span><span id="line-38">                 <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span>
</span><span id="line-39">                 <span class="p">(</span><span class="nf">snd</span> <span class="nv">ch</span> <span class="nv">m</span><span class="p">))</span>
</span><span id="line-40">               <span class="p">(</span><span class="nb">join </span><span class="nv">fiber</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">16</span><span class="p">)))</span>
</span></code></pre></div>
</div>

      <hr>

      <footer>
        <div>
          <div>&copy; 2013, Parallel Universe Software Co.</div>
        </div>
      </footer>

    </div>
  </div>
</div>

<!-- <script src="/pulsar/js/prettify/prettify.js"></script> -->
<script src="/pulsar/js/jquery.min.js"></script>
<script src="/pulsar/bootstrap/js/bootstrap.min.js"></script>
<script src="/pulsar/js/bootstrap-scrollspy.js"></script>
<script>


  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25007319-2']);
  _gaq.push(['_trackPageview']);
  
  (function() {
    var ga = document.createElement('script'); 
    ga.type = 'text/javascript'; 
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; 
    s.parentNode.insertBefore(ga, s);
  })();


// Change "active" style on selected left-hand navigation menu item.
$(document).ready(function () {
  var path = location.pathname;
  $('ul.nav > li > a[href="' + path + '"]').parent().addClass('active');

  // TODO: Use kramdown {:.prettyprint .linenums .lang-ruby} to add the
  // <pre class="prettyprint"> instead of doing this client-side.

  // $('pre:has(code:not(.language-txt))').addClass('prettyprint');
  // window.prettyPrint && prettyPrint();
});
</script>

</body>
</html>
