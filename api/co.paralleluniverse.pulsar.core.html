<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html"><span>co.paralleluniverse.pulsar.async</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.core.html#var--%3Etimeunit"><span>-&gt;timeunit</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-alive%3F"><span>alive?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-channel"><span>channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-close%21"><span>close!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-closed%3F"><span>closed?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-convert-duration"><span>convert-duration</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-fiber"><span>current-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-strand"><span>current-strand</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-defsusfn"><span>defsusfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-double-channel"><span>double-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber"><span>fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber-%3Efuture"><span>fiber-&gt;future</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fj-pool"><span>fj-pool</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-float-channel"><span>float-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-int-channel"><span>int-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-join"><span>join</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-long-channel"><span>long-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-make-fj-pool"><span>make-fj-pool</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-promise"><span>promise</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv-group"><span>rcv-group</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-sel"><span>sel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-select"><span>select</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd"><span>snd</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-fiber"><span>spawn-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-thread"><span>spawn-thread</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-start"><span>start</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-subscribe%21"><span>subscribe!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-susfn"><span>susfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%21"><span>suspendable!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%3F"><span>suspendable?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-ticker-consumer"><span>ticker-consumer</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-topic"><span>topic</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-rcv"><span>try-rcv</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd"><span>try-snd</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-unsubscribe%21"><span>unsubscribe!</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.core documentation</h2><pre class="doc">Pulsar is an implementation of lightweight threads (fibers),
Go-like channles and Erlang-like actors for the JVM</pre><div class="public" id="var--%3Etimeunit"><h3>-&gt;timeunit</h3><div class="usage"><code>(-&gt;timeunit x)</code></div><pre class="doc">Constructs an instance of `java.util.concurrent.TimeUnit`.
If argument x is already an instance of `TimeUnit`, the function returns x.
Otherwise, x *must* be a keyword, in which case the following conversion
is performed:

&lt;pre&gt;
:nanoseconds | :nanos | :ns   -&gt; TimeUnit/NANOSECONDS
:microseconds | :us           -&gt; TimeUnit/MICROSECONDS
:milliseconds | :millis | :ms -&gt; TimeUnit/MILLISECONDS
:seconds | :sec               -&gt; TimeUnit/SECONDS
:minutes | :mins              -&gt; TimeUnit/MINUTES
:hours | :hrs                 -&gt; TimeUnit/HOURS
:days                         -&gt; TimeUnit/DAYS
&lt;/pre&gt;
</pre></div><div class="public" id="var-alive%3F"><h3>alive?</h3><div class="usage"><code>(alive? a)</code></div><pre class="doc">Tests whether or not a strand is alive. 
A strand is alive if it has been started but has not yet died.</pre></div><div class="public" id="var-channel"><h3>channel</h3><div class="usage"><code>(channel capacity overflow-policy)</code><code>(channel capacity)</code><code>(channel)</code></div><pre class="doc">Creates a new channel.

Optional arguments:
capacity        - specifies how many messages the channel can contain (until they are consumed)
                  * A value of `0` designates a *transfer channel*, that blocks both `snd` and `rcv` 
                    until a corresponding operation (`rcv` or `snd` respectively) is called.
                  * A value of `-1` creates an unbounded channel.

                  default: 0

overflow-policy - specifies what `snd` does when the channel's capacity is exhausted.
                  May be one of:
                  * :throw    - throws an exception.
                  * :block    - blocks until a message is consumed and room is available
                  * :drop     - the message is silently dropped
                  * :displace - the old message waiting in the queue is discarded to make room for the new message.
                  
                  default: :block

The default channel capacity is 0 and the default policy is :block</pre></div><div class="public" id="var-close%21"><h3>close!</h3><div class="usage"><code>(close! channel)</code></div><pre class="doc">Closes a channel.
Messages already in the channel will be received, but all future attempts at `snd`
will silently discard the message.</pre></div><div class="public" id="var-closed%3F"><h3>closed?</h3><div class="usage"><code>(closed? channel)</code></div><pre class="doc">Tests whether a channel has been closed and contains no more messages that 
can be received.</pre></div><div class="public" id="var-convert-duration"><h3>convert-duration</h3><div class="usage"><code>(convert-duration x from-unit to-unit)</code></div><pre class="doc">Converts a time duration from one time unit to another.
x is the duration; `from-unit` and `to-unit` are the source
and target units repsectively, given as either a j.u.c.TimeUnit instance
or as a keyword, as specified by `-&gt;timeunit`.</pre></div><div class="public" id="var-current-fiber"><h3>current-fiber</h3><div class="usage"><code>(current-fiber)</code></div><pre class="doc">Returns the currently running lightweight-thread or `nil` if none.
</pre></div><div class="public" id="var-current-strand"><h3>current-strand</h3><div class="usage"><code>(current-strand)</code></div><pre class="doc">Returns the currently running fiber (if running in fiber)
or current thread (if not).</pre></div><div class="public" id="var-defsusfn"><h3>defsusfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(defsusfn &amp; expr)</code></div><pre class="doc">Defines a suspendable function that can be used by a fiber or actor.
Used exactly like 'defn'</pre></div><div class="public" id="var-double-channel"><h3>double-channel</h3><div class="usage"><code>(double-channel size overflow-policy)</code><code>(double-channel size)</code><code>(double-channel)</code></div><pre class="doc">Creates a double channel
</pre></div><div class="public" id="var-fiber"><h3>fiber</h3><div class="usage"><code>(fiber &amp; args)</code></div><pre class="doc">Creates, but does not start a new fiber (a lightweight thread) running in a fork/join pool.

It is much preferable to use `spawn-fiber`.</pre></div><div class="public" id="var-fiber-%3Efuture"><h3>fiber-&gt;future</h3><div class="usage"><code>(fiber-&gt;future f)</code></div><pre class="doc">Takes a spawned fiber yields a future object that will
invoke the function in another thread, and will cache the result and
return it on all subsequent calls to deref/@. If the computation has
not yet finished, calls to deref/@ will block, unless the variant
of deref with timeout is used. See also - realized?.</pre></div><div class="public" id="var-fj-pool"><h3>fj-pool</h3><div class="usage"></div><pre class="doc">A global fork/join pool. The pool uses all available processors and runs in the async mode.
</pre></div><div class="public" id="var-float-channel"><h3>float-channel</h3><div class="usage"><code>(float-channel size overflow-policy)</code><code>(float-channel size)</code><code>(float-channel)</code></div><pre class="doc">Creates a float channel
</pre></div><div class="public" id="var-int-channel"><h3>int-channel</h3><div class="usage"><code>(int-channel size overflow-policy)</code><code>(int-channel size)</code><code>(int-channel)</code></div><pre class="doc">Creates an int channel
</pre></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join s)</code><code>(join timeout unit s)</code></div><pre class="doc">Awaits the termination of the given strand or strands, and returns
their result, if applicable.

If a single strand is given, its result is returned;
if a collection - then a collection of the repsective results.

Note that for threads, the result is always `nil`, as threads don't return a value.

If a timeout is supplied and it elapses before the strand has terminated,
a j.u.c.TimeoutException is thrown.

s       - either a strand or a collection of strands.
timeout - how long to wait for the strands termination
unit    - the unit of the timeout duration. TimeUnit or keyword as in `-&gt;timeunit`</pre></div><div class="public" id="var-long-channel"><h3>long-channel</h3><div class="usage"><code>(long-channel size overflow-policy)</code><code>(long-channel size)</code><code>(long-channel)</code></div><pre class="doc">Creates a long channel
</pre></div><div class="public" id="var-make-fj-pool"><h3>make-fj-pool</h3><div class="usage"><code>(make-fj-pool parallelism async)</code></div><pre class="doc">Creates a new ForkJoinPool with the given parallelism and with the given async mode
</pre></div><div class="public" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise)</code><code>(promise f)</code></div><pre class="doc">Returns a promise object that can be read with deref/@, and set,
once only, with deliver. Calls to deref/@ prior to delivery will
block, unless the variant of deref with timeout is used. All
subsequent derefs will return the same delivered value without
blocking. See also - realized?.

Unlike clojure.core/promise, this promise object can be used inside Pulsar fibers.</pre></div><div class="public" id="var-rcv-group"><h3>rcv-group</h3><div class="usage"><code>(rcv-group ports)</code><code>(rcv-group port &amp; ports)</code></div><pre class="doc">Creates a receive-port (a read-only channel) from a group of channels.
Receiving a message from the group will return the next message available from
any of the channels in the group.
A message received from the group is consumed (removed) from the original member
channel to which it has been sent.</pre></div><div class="public" id="var-sel"><h3>sel</h3><div class="usage"><code>(sel ports &amp; {:as opts})</code></div><pre class="doc">Performs up to one of several given channel operations.
sel takes a collection containing *channel operation descriptors*. A descriptor is 
either a channel or a pair (vector) of a channel and a message. 
Each channel in the sequence represents a `rcv` attempt, and each channel-message pair 
represents a `snd` attempt. 
The `sel` function performs at most one operation on the sequence, a `rcv` or a `snd`, 
which is determined by the first operation that can succeed. If no operation can be 
carried out immediately, `sel` will block until an operation can be performed, or the
optionally specified timeout expires.
If two or more operations are available at the same time, one of them will be chosen
at random, unless the `:priority` option is set to `true`.

Options:
:priority bool -  If set to `true`, then whenever two or more operations are available
                  the first among them, in the order they are listed in the `ports` collection,
                  will be the one executed.
:timeout millis - If timeout is set and expires before any of the operations are available,
                  the function will return `nil`

Returns:
If an operation succeeds, returns a vector `[m ch]` with `m` being the message received if the
operation is a `rcv`, or `nil` if it's a `snd`, and `ch` is the channel on which the succesful
opration was performed.
If a timeout is set and expires before any of the operations are available, returns `nil`.</pre></div><div class="public" id="var-select"><h3>select</h3><h4 class="macro">macro</h4><div class="usage"><code>(select &amp; clauses)</code></div><pre class="doc">Performs a very similar operation to `sel`, but allows you to specify an action to perform depending 
on which operation has succeeded.
Takes an even number of expressions, ordered as (ops1, action1, ops2, action2 ...) with the ops being 
a channel operation descriptior (remember: a descriptor is either a channel for an `rcv` operation, 
or a vector of a channel and a message specifying a `snd` operation) or a collection of descriptors, 
and the actions are Clojure expressions. 
Like `sel`, `select` performs at most one operation, in which case it will run the operation's 
respective action and return its result.

An action expression can bind values to the operations results. 
The action expression may begin with a vector of one or two symbols. In that case, the first symbol 
will be bound to the message returned from the successful receive in the respective ops clause 
(or `nil` if the successful operation is a `snd`), and the second symbol, if present, will be bound 
to the successful operation's channel.

Like `sel`, `select` blocks until an operation succeeds, or, if a `:timeout` option is specified, 
until the timeout (in milliseconds) elapses. If a timeout is specfied and elapses, `select` will run 
the action in an optional `:else` clause and return its result, or, if an `:else` clause is not present, 
`select` will return `nil`.

Example:

(select :timeout 100 
       c1 ([v] (println &quot;received&quot; v))
       [[c2 m2] [c3 m3]] ([v c] (println &quot;sent to&quot; c))
       :else &quot;timeout!&quot;)

In the example, if a message is received from channel `c1`, then it will be printed. 
If a message is sent to either `c2` or `c3`, then the identity of the channel will be printed, 
and if the 100 ms timeout elapses then &quot;timeout!&quot; will be printed.</pre></div><div class="public" id="var-snd"><h3>snd</h3><div class="usage"><code>(snd channel message)</code></div><pre class="doc">Sends a message to a channel.
If the channel's overflow policy is `:block` than this function will block
if the channels' capacity is exceeded.</pre></div><div class="public" id="var-spawn-fiber"><h3>spawn-fiber</h3><h4 class="macro">macro</h4><div class="usage"><code>(spawn-fiber :name? :stack-size? :fj-pool? f &amp; args)</code></div><pre class="doc">Creates and starts a new fiber.

f - the function to run in the fiber.
args - (optional) arguments to pass to the function

Options:
:name str     - the fiber's name
:stack-size n - the fiber's initial stack size
:fj-pool      - the fork-join pool in which the fiber will run
</pre></div><div class="public" id="var-spawn-thread"><h3>spawn-thread</h3><div class="usage"><code>(spawn-thread :name? f &amp; args)</code></div><pre class="doc">Creates and starts a new thread.

f - the function to run in the thread.
args - (optional) arguments to pass to the function

Options:
:name str     - the thread's name</pre></div><div class="public" id="var-start"><h3>start</h3><div class="usage"><code>(start fiber)</code></div><pre class="doc">Starts a fiber created with `fiber`.
</pre></div><div class="public" id="var-subscribe%21"><h3>subscribe!</h3><div class="usage"><code>(subscribe! topic channel)</code></div><pre class="doc">Subscribes a channel to a topic.
The subscribed channel will receive all messages sent to the topic.</pre></div><div class="public" id="var-susfn"><h3>susfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(susfn &amp; expr)</code></div><pre class="doc">Creates a suspendable function that can be used by a fiber or actor.
Used exactly like 'fn</pre></div><div class="public" id="var-suspendable%21"><h3>suspendable!</h3><div class="usage"><code>(suspendable! f)</code><code>(suspendable! x prot)</code></div><pre class="doc">Makes a function suspendable.
</pre></div><div class="public" id="var-suspendable%3F"><h3>suspendable?</h3><div class="usage"><code>(suspendable? f)</code></div><pre class="doc">Returns true of a function has been instrumented as suspendable; false otherwise.
</pre></div><div class="public" id="var-ticker-consumer"><h3>ticker-consumer</h3><div class="usage"><code>(ticker-consumer ticker)</code></div><pre class="doc">Creates a rcv-port (read-only channel) that returns messages from a *ticker channel*.
A ticker channel is a bounded channel with an overflow policy of :displace.

Different ticker consumers are independent (a message received from one is not removed from others),
and guarantee monotonicty (messages are received in order), but if messages are sent to the
ticker channel faster than they are consumed then messages can be lost.</pre></div><div class="public" id="var-topic"><h3>topic</h3><div class="usage"><code>(topic)</code></div><pre class="doc">Creates a new topic.
A topic is a send-port (a write-only channel) that forwards every message sent to it
to a group of subscribed channels.
Use `subscribe!` and `unsubscribe!` to subscribe and unsubscribe a channel to or from
the topic.</pre></div><div class="public" id="var-try-rcv"><h3>try-rcv</h3><div class="usage"><code>(try-rcv channel)</code></div><pre class="doc">Attempts to immediately (without blocking) receive a message from a channel.
Returns the message if one is immediately available; `nil` otherwise.
This function never blocks.</pre></div><div class="public" id="var-try-snd"><h3>try-snd</h3><div class="usage"><code>(try-snd channel message)</code></div><pre class="doc">Tries to immediately send a message to a channel.
If the channel's capacity is exceeded, this function fails and returns `false`.
Returns `true` if the operation succeeded; `false` otherwise.
This function never blocks.</pre></div><div class="public" id="var-unsubscribe%21"><h3>unsubscribe!</h3><div class="usage"><code>(unsubscribe! topic channel)</code></div><pre class="doc">Unsubscribes a channel from a topic.
The channel will stop receiving messages sent to the topic.</pre></div></div></body></html>