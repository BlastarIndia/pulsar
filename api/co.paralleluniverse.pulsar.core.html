<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.core.html#var-alive%3F"><span>alive?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-apply-variadic"><span>apply-variadic</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-as-timeunit"><span>as-timeunit</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-attach%21"><span>attach!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-channel"><span>channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-channel-group"><span>channel-group</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-fiber"><span>current-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-strand"><span>current-strand</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-defsusfn"><span>defsusfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-double-channel"><span>double-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber"><span>fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber-%3Efuture"><span>fiber-&gt;future</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fj-pool"><span>fj-pool</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-float-channel"><span>float-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-int-channel"><span>int-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-long-channel"><span>long-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-make-fj-pool"><span>make-fj-pool</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-promise"><span>promise</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv"><span>rcv</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd"><span>snd</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-fiber"><span>spawn-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-thread"><span>spawn-thread</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-start"><span>start</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-strampoline"><span>strampoline</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-susfn"><span>susfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%21"><span>suspendable!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%3F"><span>suspendable?</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.core documentation</h2><pre class="doc">Pulsar is an implementation of lightweight threads (fibers),
Go-like channles and Erlang-like actors for the JVM</pre><div class="public" id="var-alive%3F"><h3>alive?</h3><div class="usage"><code>(alive? a)</code></div><pre class="doc">Tests whether or not a strand is alive. A strand is alive if it has been started but has not yet died.
</pre></div><div class="public" id="var-apply-variadic"><h3>apply-variadic</h3><div class="usage"><code>(apply-variadic f &amp; args)</code></div><pre class="doc">Calls a variadic function by applying a concat of all arguments with the last argument (which is supposedly a collection)
</pre></div><div class="public" id="var-as-timeunit"><h3>as-timeunit</h3><div class="usage"><code>(as-timeunit x)</code></div><pre class="doc">Converts a keyword to a java.util.concurrent.TimeUnit
&lt;pre&gt;
:nanoseconds | :nanos | :ns   -&gt; TimeUnit/NANOSECONDS
:microseconds | :us           -&gt; TimeUnit/MICROSECONDS
:milliseconds | :millis | :ms -&gt; TimeUnit/MILLISECONDS
:seconds | :sec               -&gt; TimeUnit/SECONDS
:minutes | :mins              -&gt; TimeUnit/MINUTES
:hours | :hrs                 -&gt; TimeUnit/HOURS
:days                         -&gt; TimeUnit/DAYS
&lt;/pre&gt;
</pre></div><div class="public" id="var-attach%21"><h3>attach!</h3><div class="usage"><code>(attach! channel strand)</code></div><pre class="doc">Sets a channel's owning strand (fiber or thread).
This is done automatically the first time a rcv (or one of the primitive-type rcv-xxx) is called on the channel.</pre></div><div class="public" id="var-channel"><h3>channel</h3><div class="usage"><code>(channel size)</code><code>(channel)</code></div><pre class="doc">Creates a channel
</pre></div><div class="public" id="var-channel-group"><h3>channel-group</h3><div class="usage"><code>(channel-group &amp; channels)</code></div><pre class="doc">Creates a channel group
</pre></div><div class="public" id="var-current-fiber"><h3>current-fiber</h3><div class="usage"><code>(current-fiber)</code></div><pre class="doc">Returns the currently running lightweight-thread or nil if none
</pre></div><div class="public" id="var-current-strand"><h3>current-strand</h3><div class="usage"><code>(current-strand)</code></div><pre class="doc">Returns the currently running fiber or current thread in case of new active fiber
</pre></div><div class="public" id="var-defsusfn"><h3>defsusfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(defsusfn &amp; expr)</code></div><pre class="doc">Defines a suspendable function that can be used by a fiber or actor
</pre></div><div class="public" id="var-double-channel"><h3>double-channel</h3><div class="usage"><code>(double-channel size)</code><code>(double-channel)</code></div><pre class="doc">Creates a double channel
</pre></div><div class="public" id="var-fiber"><h3>fiber</h3><div class="usage"><code>(fiber &amp; args)</code></div><pre class="doc">Creates a new fiber (a lightweight thread) running in a fork/join pool.
</pre></div><div class="public" id="var-fiber-%3Efuture"><h3>fiber-&gt;future</h3><div class="usage"><code>(fiber-&gt;future f)</code></div><pre class="doc">Takes a spawned fiber yields a future object that will
invoke the function in another thread, and will cache the result and
return it on all subsequent calls to deref/@. If the computation has
not yet finished, calls to deref/@ will block, unless the variant
of deref with timeout is used. See also - realized?.</pre></div><div class="public" id="var-fj-pool"><h3>fj-pool</h3><div class="usage"></div><pre class="doc">A global fork/join pool. The pool uses all available processors and runs in the async mode.
</pre></div><div class="public" id="var-float-channel"><h3>float-channel</h3><div class="usage"><code>(float-channel size)</code><code>(float-channel)</code></div><pre class="doc">Creates a float channel
</pre></div><div class="public" id="var-int-channel"><h3>int-channel</h3><div class="usage"><code>(int-channel size)</code><code>(int-channel)</code></div><pre class="doc">Creates an int channel
</pre></div><div class="public" id="var-long-channel"><h3>long-channel</h3><div class="usage"><code>(long-channel size)</code><code>(long-channel)</code></div><pre class="doc">Creates a long channel
</pre></div><div class="public" id="var-make-fj-pool"><h3>make-fj-pool</h3><div class="usage"><code>(make-fj-pool parallelism async)</code></div><pre class="doc">Creates a new ForkJoinPool with the given parallelism and with the given async mode
</pre></div><div class="public" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise)</code><code>(promise f)</code></div><pre class="doc">Returns a promise object that can be read with deref/@, and set,
once only, with deliver. Calls to deref/@ prior to delivery will
block, unless the variant of deref with timeout is used. All
subsequent derefs will return the same delivered value without
blocking. See also - realized?.

Unlike clojure.core/promise, this promise object can be used inside Pulsar fibers.</pre></div><div class="public" id="var-rcv"><h3>rcv</h3><div class="usage"><code>(rcv channel)</code><code>(rcv channel timeout unit)</code></div><pre class="doc">Receives a message from a channel or a channel group.
If a timeout is given, and it expires, rcv returns nil.</pre></div><div class="public" id="var-snd"><h3>snd</h3><div class="usage"><code>(snd channel message)</code></div><pre class="doc">Sends a message to a channel
</pre></div><div class="public" id="var-spawn-fiber"><h3>spawn-fiber</h3><h4 class="macro">macro</h4><div class="usage"><code>(spawn-fiber &amp; args)</code></div><pre class="doc">Creates and starts a new fiber
</pre></div><div class="public" id="var-spawn-thread"><h3>spawn-thread</h3><div class="usage"><code>(spawn-thread &amp; args)</code></div><pre class="doc">Creates and starts a new thread
</pre></div><div class="public" id="var-start"><h3>start</h3><div class="usage"><code>(start fiber)</code></div><pre class="doc">Starts a fiber
</pre></div><div class="public" id="var-strampoline"><h3>strampoline</h3><div class="usage"><code>(strampoline f)</code><code>(strampoline f &amp; args)</code></div><pre class="doc">A suspendable version of trampoline. Should be used to implement
finite-state-machine actors.

trampoline can be used to convert algorithms requiring mutual
recursion without stack consumption. Calls f with supplied args, if
any. If f returns a fn, calls that fn with no arguments, and
continues to repeat, until the return value is not a fn, then
returns that non-fn value. Note that if you want to return a fn as a
final value, you must wrap it in some data structure and unpack it
after trampoline returns.</pre></div><div class="public" id="var-susfn"><h3>susfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(susfn &amp; expr)</code></div><pre class="doc">Creates a suspendable function that can be used by a fiber or actor
</pre></div><div class="public" id="var-suspendable%21"><h3>suspendable!</h3><div class="usage"><code>(suspendable! f)</code><code>(suspendable! x prot)</code></div><pre class="doc">Makes a function suspendable
</pre></div><div class="public" id="var-suspendable%3F"><h3>suspendable?</h3><div class="usage"><code>(suspendable? f)</code></div><pre class="doc">Returns true of a function has been instrumented as suspendable; false otherwise.
</pre></div></div></body></html>