<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.lazyseq documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-channel-%3Elazy-seq"><span>channel-&gt;lazy-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-doall"><span>doall</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-dorun"><span>dorun</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-drop"><span>drop</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-filter"><span>filter</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-lazy-seq"><span>lazy-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-map"><span>map</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-nthnext"><span>nthnext</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-nthrest"><span>nthrest</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-repeatedly"><span>repeatedly</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-snd-seq"><span>snd-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-take"><span>take</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-take-while"><span>take-while</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.lazyseq documentation</h2><pre class="doc">Functions to transform a channel into a laze seq
</pre><div class="public" id="var-channel-%3Elazy-seq"><h3>channel-&gt;lazy-seq</h3><div class="usage"><code>(channel-&gt;lazy-seq channel)</code><code>(channel-&gt;lazy-seq channel timeout unit)</code></div><pre class="doc">Turns a channel into a lazy-seq
</pre></div><div class="public" id="var-doall"><h3>doall</h3><div class="usage"><code>(doall coll)</code><code>(doall n coll)</code></div><pre class="doc">When lazy sequences are produced via functions that have side
effects, any effects other than those needed to produce the first
element in the seq do not occur until the seq is consumed. doall can
be used to force any effects. Walks through the successive nexts of
the seq, retains the head and returns it, thus causing the entire
seq to reside in memory at one time.</pre></div><div class="public" id="var-dorun"><h3>dorun</h3><div class="usage"><code>(dorun coll)</code><code>(dorun n coll)</code></div><pre class="doc">When lazy sequences are produced via functions that have side
effects, any effects other than those needed to produce the first
element in the seq do not occur until the seq is consumed. dorun can
be used to force any effects. Walks through the successive nexts of
the seq, does not retain the head and returns nil.</pre></div><div class="public" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop n coll)</code></div><pre class="doc">Returns a lazy sequence of all but the first n items in coll.
</pre></div><div class="public" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter pred coll)</code></div><pre class="doc">Returns a lazy sequence of the items in coll for which
(pred item) returns true. pred must be free of side-effects.</pre></div><div class="public" id="var-lazy-seq"><h3>lazy-seq</h3><h4 class="macro">macro</h4><div class="usage"><code>(lazy-seq &amp; body)</code></div><pre class="doc">Takes a body of expressions that returns an ISeq or nil, and yields
a Seqable object that will invoke the body only the first time seq
is called, and will cache the result and return it on all subsequent
seq calls. See also - realized?</pre></div><div class="public" id="var-map"><h3>map</h3><div class="usage"><code>(map f coll)</code></div><pre class="doc">Returns a lazy sequence consisting of the result of applying f to the
set of first items of each coll, followed by applying f to the set
of second items in each coll, until any one of the colls is
exhausted.  Any remaining items in other colls are ignored. Function
f should accept number-of-colls arguments.</pre></div><div class="public" id="var-nthnext"><h3>nthnext</h3><div class="usage"><code>(nthnext coll n)</code></div><pre class="doc">Returns the nth next of coll, (seq coll) when n is 0.
</pre></div><div class="public" id="var-nthrest"><h3>nthrest</h3><div class="usage"><code>(nthrest coll n)</code></div><pre class="doc">Returns the nth rest of coll, coll when n is 0.
</pre></div><div class="public" id="var-repeatedly"><h3>repeatedly</h3><div class="usage"><code>(repeatedly f)</code><code>(repeatedly n f)</code></div><pre class="doc">Takes a function of no args, presumably with side effects, and
returns an infinite (or length n if supplied) lazy sequence of calls
to it</pre></div><div class="public" id="var-snd-seq"><h3>snd-seq</h3><div class="usage"><code>(snd-seq channel ms)</code></div><pre class="doc">Sends a sequence of messages to a channel
</pre></div><div class="public" id="var-take"><h3>take</h3><div class="usage"><code>(take n coll)</code></div><pre class="doc">Returns a lazy sequence of the first n items in coll, or all items if
there are fewer than n.</pre></div><div class="public" id="var-take-while"><h3>take-while</h3><div class="usage"><code>(take-while pred coll)</code></div><pre class="doc">Returns a lazy sequence of successive items from coll while
(pred item) returns true. pred must be free of side-effects.</pre></div></div></body></html>