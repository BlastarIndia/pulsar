<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.lazyseq documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html"><span>co.paralleluniverse.pulsar.async</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-channel-%3Elazy-seq"><span>channel-&gt;lazy-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-drop"><span>drop</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-filter"><span>filter</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-lazy-seq"><span>lazy-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-map"><span>map</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-repeatedly"><span>repeatedly</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-snd-seq"><span>snd-seq</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-take"><span>take</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html#var-take-while"><span>take-while</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.lazyseq documentation</h2><pre class="doc">Functions to transform a channel into a laze seq
</pre><div class="public" id="var-channel-%3Elazy-seq"><h3>channel-&gt;lazy-seq</h3><div class="usage"><code>(channel-&gt;lazy-seq channel)</code><code>(channel-&gt;lazy-seq channel timeout unit)</code></div><pre class="doc">Turns a channel into a lazy-seq.
</pre></div><div class="public" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop n coll)</code></div><pre class="doc">Returns a lazy sequence of all but the first n items in coll.
</pre></div><div class="public" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter pred coll)</code></div><pre class="doc">Returns a lazy sequence of the items in coll for which
(pred item) returns true. pred must be free of side-effects.</pre></div><div class="public" id="var-lazy-seq"><h3>lazy-seq</h3><h4 class="macro">macro</h4><div class="usage"><code>(lazy-seq &amp; body)</code></div><pre class="doc">Takes a body of expressions that returns an ISeq or nil, and yields
a Seqable object that will invoke the body only the first time seq
is called, and will cache the result and return it on all subsequent
seq calls. See also - realized?</pre></div><div class="public" id="var-map"><h3>map</h3><div class="usage"><code>(map f coll)</code></div><pre class="doc">Returns a lazy sequence consisting of the result of applying f to the
set of first items of each coll, followed by applying f to the set
of second items in each coll, until any one of the colls is
exhausted.  Any remaining items in other colls are ignored. Function
f should accept number-of-colls arguments.</pre></div><div class="public" id="var-repeatedly"><h3>repeatedly</h3><div class="usage"><code>(repeatedly f)</code><code>(repeatedly n f)</code></div><pre class="doc">Takes a function of no args, presumably with side effects, and
returns an infinite (or length n if supplied) lazy sequence of calls
to it</pre></div><div class="public" id="var-snd-seq"><h3>snd-seq</h3><div class="usage"><code>(snd-seq channel ms)</code></div><pre class="doc">Sends a sequence of messages to a channel
</pre></div><div class="public" id="var-take"><h3>take</h3><div class="usage"><code>(take n coll)</code></div><pre class="doc">Returns a lazy sequence of the first n items in coll, or all items if
there are fewer than n.</pre></div><div class="public" id="var-take-while"><h3>take-while</h3><div class="usage"><code>(take-while pred coll)</code></div><pre class="doc">Returns a lazy sequence of successive items from coll while
(pred item) returns true. pred must be free of side-effects.</pre></div></div></body></html>